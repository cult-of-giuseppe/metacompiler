\subsection{Conclusions}

In this chapter we have seen how to define the operational semantics for a programming language. Usually this semantics is written on paper formally, but the elegance and clarity of the formal model is lost in the implementation phase. This is due to the fact that compilers are written using commercial general purpose programming languages which do not provide constructs to ease the implementation of such formal models. Even when using functional programming languages which offer more expressiveness than imperative languages it is not possible to have a one-to-one mapping from semantics rule to the implementation. The meta-compiler instead offers a way to directly map these rules into code, making it more compact and clear. Of course we must trade off simplicity and compactness for performances, but static analysis techniques on the generated code might drastically improve the performance of the code generated by the meta-compiler.